# 아이템 26. 로 타입은 사용하지 말라

* 클래스와 인터페이스 선언에 아래와 같이 타입 매개변수가 쓰이면 제네릭 클래스 혹은 제네릭 인터페이스라고 한다.

```java
public class Box<T> {
    // ...
}
```

* 위의 예시 코드에서 `<T>`를 타입 매개변수라고 하며 이 타입 매개변수를 전혀 사용하지 않을 때를 로 타입이라고 한다.

```java
// Bad
public Box box = ...

// Good
public Box<String> box = ...
```

* 만약 `Bad`와 같이 타입을 명시하지 않게 되면 엉뚱한 타입의 인스턴스를 취급할 수 있어 오류가 발생하기 쉽다.
* 하지만 `Good`과 같이 타입을 명시해주면 컴파일러는 String 타입의 인스턴스만을 넣어야 함을 인지하게 되면서 타입 안정성을 확보할 수 있게 된다.
* 컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않도록 보장해준다.
* 실패하지 않는다는 것을 알고 있음에도 불구하고 로 타입을 사용하지 말아야 하는 이유는 제네릭이 가져다주는 타입 안정성과 표현력을 잃게 되기 때문이다.
* 이 로 타입은 호환성 때문에 놔두고 있는 것이다.

### [ 로 타입은 안전하지 않으니 와일드 카드를 사용하자 ]

* 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않다면 물음표(?)를 사용하면 된다.

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
```

* 물음표(?)만 사용해서 타입 제한을 걸지 않은 경우라면 <? extends Object>와 같다. 이것을 비제한 와일드카드라고 한다.
* `<?>` 타입 제한을 둘 때 extends를 사용하면 상한선을, super를 사용하면 하한선을 둘 수 있다.
* 로 타입을 쓰지 말라는 것이 이 아이템의 주제이나 몇 가지 예외사항이 있다.

1. Class 리터럴에는 Raw Type을 사용해야 한다.

* 자바 명세에는 Class 리터럴에 매개변수화 타입을 사용하지 못하게 한다.
* List.class, String[].class는 허용되나 List<?>.class는 허용되지 않는다.

2. instanceof 연산자

* 런타임 시에는 제네릭 타입 정보가 지워지게 된다.
* 따라서 런타임 시에는 instanceof를 사용할 수 없다.
* 그러므로 instanceof 연산자를 사용할 때는 raw type을 사용해도 된다.

```java
if (o instanceof Set) {
    Set<?> s = (Set<?>) o;
}
```