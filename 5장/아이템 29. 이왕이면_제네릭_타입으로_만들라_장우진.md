# 아이템 29. 이왕이면 제네릭 타입으로 만들라

```java
public class MyStack {

	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public MyStack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(Object o) {
		ensureCapacity();	// 용량 증가
		elements[size++] = o;
	}

	public Object pop() {
		if (size == 0) {
			throw new EmptyStackException();
		}
		Object result = elements[--size];
		elements[size] = null;	// 다 쓴 참조 해제(메모리 누수 방지)
		return result;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	private void ensureCapacity() {
		if (elements.length == size) {
			elements = Arrays.copyOf(elements,2  * size + 1);
		}
	}

	public static void main(String[] args) {

		MyStack myStack = new MyStack();

		myStack.push(1);
		myStack.push("1");

		System.out.println("class = " + myStack.pop().getClass()); // class = class java.lang.String
		System.out.println("class = " + myStack.pop().getClass()); // class = class java.lang.Integer
	}
}
```

* 위의 코드에서 `pop()`을 통해 원소를 꺼낼 때 현재 배열의 타입이 Object[]로, 최상위 부모이기 때문에 원소를 꺼낼 때마다 형변환을 해주어야 한다.
* 이 때, 런타임 오류가 발생할 위험이 있다.
* 위의 코드를 제네릭을 활용해서 개선하면 아래와 같다.

```java
public class MyStack<E> {

	private E[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public MyStack() {
		elements = new E[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(E e) {
		ensureCapacity();    // 용량 증가
		elements[size++] = e;
	}

	public E pop() {
		if (size == 0) {
			throw new EmptyStackException();
		}
		E result = elements[--size];
		elements[size] = null;    // 다 쓴 참조 해제(메모리 누수 방지)
		return result;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	private void ensureCapacity() {
		if (elements.length == size) {
			elements = Arrays.copyOf(elements, 2 * size + 1);
		}
	}
}
```

* 하지만 위의 코드는 에러가 발생하는데 그 이유는 타입 이레이저에 의해 런타임 시 타입 매개변수가 사라지면서 `elements = new E[DEFAULT_INITIAL_CAPACITY];` 부분에서 타입 매개변수 E는 인스턴스화를 할 수 없기 때문이다.
* 이 문제에 대한 2가지 해결 방법을 들 수 있다.

### [ Object 배열로 생성하고 다운 캐스팅을 제네릭 배열로 하는 방법 ]
```java
@SuppressWarnings("unchecked")
public MyStack() {
    // elements의 타입은 E[]
    // Object[]를 E[]로 캐스팅하면 둘 다 같은 타입이 된다.
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}
```

### [ 배열의 원소 타입을 타입 매개변수로 변경하는 방법 ]

```java
public E pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    E result = (E) elements[--size]; 
    elements[size] = null;	// 다 쓴 참조 해제(메모리 누수 방지)
    return result;
}
```

* 첫 번째 방법을 좀 더 선호한다.
  * 가독성이 좋다. 배열 타입을 E[]로 선언하여 오직 E 타입의 인스턴스만 받음을 명시한다.
  * 캐스팅을 배열 초기화 시 단 한 번만 해주면 된다. 두 번째 방법의 경우 매번 `pop()` 메서드를 호출할 때마다 캐스팅을 해줘야 한다.